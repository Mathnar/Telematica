\documentclass{esculapio}

\usepackage[italian]{babel}
\usepackage{bigstrut}
\usepackage{adjustbox,threeparttable}
\newcommand{\avtg}{\fontsize{9}{12}\fontfamily{pag}\selectfont Avant Garde\normalfont\normalsize}
\newcommand{\book}{\texttt{book.cls}}
\usepackage[latin1]{inputenc}

\usepackage{pgfplots}
\usepackage{amsthm} %per teorema
\usepackage{tikz-cd}
\usepackage{drawstack}
\theoremstyle{plain}
\usetikzlibrary{calc}
\usepackage[T1]{fontenc}
\usetikzlibrary{positioning, shapes}
\usepackage{graphicx}
\usepackage{graphicx,changepage}
\usepackage{grffile}

\usetikzlibrary{arrows,shadows,positioning}

\usepackage[acronym,nonumberlist]{glossaries}

\makeglossaries

\newacronym{HTTP}{HTTP}{HyperText Transfer Protocol}
\newacronym{FTP}{FTP}{File Transfer Protocol}
\newacronym{DNS}{DNS}{Domain Name System}
\newacronym{SMTP}{SMTP}{Simple Mail Transfer Protocol}
\newacronym{UDP}{UDP}{User Datagram Protocol}
\newacronym{ARPANET}{ARPANET}{Advanced Research Projects Agency Network}
\newacronym{WWW}{WWW}{World Wide Web}
\newacronym{WoT}{WoT}{Web of Things}

\newlength\Textwd
\setlength\Textwd{3cm}
\newcommand\Textbox[2]{%
  \parbox[c][#1][c]{\Textwd}{\centering#2}}


\title{\ClassE}
\author{Francesco Bucciarelli -- M. Allegro}

\begin{document}

\begin{titlepage}
\begin{center}
	\LARGE Francesco Chiti
\end{center}
\vspace*{\stretch{1}}
\rule[1mm]{\textwidth}{1.2mm}
\begin{flushright}
	{\Huge
	\vspace{2mm}
	Internet: Evoluzione, Architetture e Applicazioni}\\
	\vspace{2mm}
\end{flushright}
\rule[1mm]{\textwidth}{1.2mm}
\vspace*{\stretch{2}}
\end{titlepage}

\tableofcontents

\chapter*{Prefazione}

%\addcontentsline{toc}{chapter}{Introduzione}





\chapter{Introduzione}\label{sec.Introduzione}

\section{Motivazioni}

\section{Vantaggi connessi alle reti}

\section{Evoluzione storica di Internet}




\section{Attori e Interfacce di rete}

\subsection{Componenti}

\subsection{Collegamenti}

\subsection{Classificazione delle reti}

\subsection{Interfacce}


\section{Programmazione delle socket}

\section{Modello funzionale a livelli}

\subsection{Principi fondativi}

\subsection{Vantaggi e svantaggi}

\subsection{Principio cross-layer}

\section{Standard ISO-OSI}

\section{Standard de facto TCP/IP}   

\subsection{Elementi di rete}




\chapter{Livello Applicativo}\label{sec.Applicazione}
\section*{Introduzione}
In questo capitolo verranno analizzati i livelli funzionali che caratterizzano entrambi i modelli standard di una rete informatica: il modello \textit{ISO/OSI} ed il modello\textit{ TCP/IP}. \\
Benché lo standard internazionale per la comunicazione sia rappresentato dal modello ISO/OSI, esso è utilizzato più come un modello astratto di riferimento. Nella pratica comune lo standard di riferimento è il modello TCP/IP, caratterizzato da un numero inferiore di livelli e da una elevata praticità dovuta ad una maggiore facilità nella manutenzione, nell'aggiornamento e più in generale nella gestione dei livelli.
\begin{figure}[h]
\begin{center}
\begin{tikzpicture}[auto,
rect/.style={
  rectangle split, rectangle split parts=7,
  draw, thick, rounded corners,
  text width=4cm,
  text centered,
  rectangle split part fill={white}
}]
\node (stack) [rect] {
\nodepart {one} \Textbox{0.5cm}{Applicazione}
\nodepart {two} \Textbox{0.4cm}{Presentazione}
\nodepart{three} \Textbox{0.7cm}{Sessione}
\nodepart{four}\Textbox{0.5cm}{Trasporto}
\nodepart{five} \Textbox{0.5cm}{Rete}
\nodepart{six} \Textbox{0.8cm}{Collegamento Dati}
\nodepart{seven} \Textbox{1cm}{Fisico}
};
\draw [thick,dash dot] (stack.west) (-2,1.19) -- (-0.75,1.19);
\draw [thick,dash dot] (stack.west) (0.8,1.19) -- (2,1.19);
\end{tikzpicture} 
\begin{tikzpicture}[auto,
rect/.style={
  rectangle split, rectangle split parts=4,
  draw, thick, rounded corners,
  text width=4cm,
  text centered,
  rectangle split part fill={white}
}]
\node (stack) [rect] {
\nodepart {one} \Textbox{1.66cm}{Applicazione}
\nodepart {two} \Textbox{0.94cm}{Trasporto}
\nodepart{three} \Textbox{0.5cm}{Rete}
\nodepart{four}\Textbox{2.08cm}{Accesso alla rete (Fisico)}
};
\end{tikzpicture}
\caption{Richiamo alla struttura dei modelli ISO/OSI (sinistra) e TCP/IP (destra).}
\end{center}
\end{figure}
I livelli ISO/OSI coinvolti nel processo di riduzione sono quelli che andremo ad analizzare in questo capitolo, definendoli ed approfondendone i principali servizi offerti.\\ Il \textit{livello Applicativo} (o Applicazione) è il settimo e più esterno livello nel modello ISO/OSI ed il quarto (o quinto) livello nel TCP/IP. Le diverse accezioni che assume tale strato nei due standard sarà motivo di studio nelle sezioni successive.\\
Prima di andare ad approfondire i servizi offerti dai livelli dei due standard, si tratterà di come si sono sviluppate le \textit{applicazioni Web}, a partire dalla nascita di Internet fino ad arrivare ad oggi, in modo da avere un quadro generale dello sviluppo delle tecnologie che hanno permesso e permettono tutt'ora l'evoluzione della Rete.
\section{Funzionalità}
Il livello Applicazione è un livello astratto che ha la funzione di specificare nel punto logico di accesso a una rete le interfacce ed i protocolli di comunicazione utilizzati e più in generale, di fornire servizi ai processi distribuiti in rete al fine di garantire uno scambio di informazioni.\\\
Quando due programmi devono comunicare tra loro è necessario prima di tutto che venga stabilito un modello di rete, e che esista una connessione logica tra le due entità (mittente e destinatario). Tramite essa si possono gestire congiuntamente i livelli dello \textit{stack TCP/IP} per mezzo di un insieme di istruzioni (o funzioni) denominate \textit{API} (\textit{Application Program Interface}) che ci permettono di aprire e chiudere connessioni ed inviare e ricevere dati. \\Durante una comunicazione ogni strato dello stack aggiunge un header al pacchetto dati che identifica il messaggio da trasmettere e le operazioni che il livello analogo deve svolgere. Questa operazione è chiamata \textbf{incapsulamento}. Per mezzo di essa è possibile identificare il dato effettivo e l'header aggiunto dallo strato attuale come un unico pacchetto dati che verrà successivamente passato allo strato sottostante. Il pacchetto risultante dal passaggio dell'intero stack verrà poi trasmesso in rete e successivamente ricevuto. Il computer o l'applicazione ricevente dovrà poi effettuare l'operazione inversa, estraendo ad ogni livello l'header necessario a pilotare le operazioni dei vari strati.
\\\\Il livello gerarchico comunemente più alto dello stack, come anticipato, è il livello Applicativo, il quale ha lo scopo di \textit{standardizzare la comunicazione}. Nel TCP/IP infatti, il livello applicativo contiene i protocolli e le interfacce di comunicazione usati nelle trasmissioni processo - processo per completare l'esecuzione dei programmi all'interno di una rete, in cui è adottato il protocollo Internet (IP). Tra i protocolli di questo strato più comunemente usati troviamo \gls{HTTP}, \gls{FTP}, \gls{DNS} e \gls{SMTP}. Un esempio di concreto utilizzo si ha ogni volta che viene richiesto al nostro Browser di accedere ad una risorsa Web tramite il processo Browser. Il livello applicativo per completare la richiesta, chiamerà in causa il protocollo HTTP.\\
Per far arrivare al Client i dati richiesti secondo lo standard TCP/IP, il livello Applicazione deve passare i dati al livello Trasporto attraverso strutture dati logiche chiamate \textit{porte}.
L'utilizzo delle porte rende molto più semplice al livello Trasporto, capire che tipo di dato gli sta venendo passato. Se ad esempio venisse inviato un dato sulla porta 25, significherebbe che il dato riguarda una richiesta e-mail. Se invece fosse stato mandato sulla porta 21 o 22, sarebbe stato un servizio FTP. Poiché sui sistemi dialoganti ci possono essere numerosi processi attivi, l'associazione alla porta giusta è un'operazione critica.  Tale funzione è svolta tramite \textbf{socket}. Un socket è una \textit{libreria standard} la cui funzione è quella di garantire l'invio e la ricezione dei dati tra Host remoti (se in una rete) o locali (\textit{Inter-Process-Communication}). Nello specifico, nello standard TCP/IP, fungono da intermediari tra il livello Applicazione ed il livello Trasporto, fornendo tra l'altro degli \textit{indirizzi di socket} agli interlocutori di ogni singola comunicazione, contenenti l'indirizzo e la porta della controparte. \\Si possono distinguere tre diversi tipi di socket in base al tipo di connessione. Gli \textbf{Stream Socket} sono basati su protocolli come il TCP e garantiscono una comunicazione affidabile di tipo full-duplex, orientata alla connessione (\textit{connection oriented}) e caratterizzata da un flusso di byte di lunghezza variabile. I \textbf{Datagram Socket} sono basati su \textit{\gls{UDP}}, un protocollo alternativo al TCP/IP che garantisce comunicazioni a bassa latenza (comunemente utilizzate per videochat) e prive di controllo del flusso. I \textbf{Raw Socket} (raw IP) hanno la caratteristica di "saltare" il livello di Trasporto, e rendere l'header accessibile direttamente al livello Applicativo. Tali indirizzi di socket sono infatti privi di una porta associata, ma contengono solo l'indirizzo dell'interlocutore.\\\\ 
Il livello Applicazione nel TCP/IP non specifica nessun tipo di regola o formato di dati accettabili, che le applicazioni devono invece tenere in conto. Per questo motivo nella prima stesura dello standard TCP/IP 	venne fortemente raccomandato di seguire il \textbf{principio di robustezza} (o legge di Postel), che recita:\\\\
\textit{"Be conservative in what you do, be liberal in what you accept from others."}\\\\
In altre parole, quando viene inviato un messaggio ad un qualsiasi destinatario risiedente in un Host differente da quello del mittente, questo deve essere perfettamente conforme alla specifica richiesta. In caso, invece, di messaggi in entrata non conformi, questi dovranno essere accettati qualora il loro significato fosse chiaro.\\\\
Nel modello ISO/OSI il livello Applicativo è costituito da un insieme di protocolli ed interfacce di comunicazione tra i quali HTTP, FTP, DNS e SMTP. Una sostanziale differenza, però, è nella struttura stessa del modello. Il livello Applicativo del TCP/IP comprende sia il livello Applicativo che i livelli Presentazione e Sessione del modello ISO/OSI. Questa maggiore modularità degli strati dello standard ISO/OSI è dovuta ad una più precisa suddivisione delle funzioni tra essi. Il livello Applicazione di tale modello, lavora infatti direttamente col software applicativo e si occupa "solo" di verificare l'esistenza di un Host per la comunicazione del flusso dati e associarlo ad un \textit{processo di rete}. Una volta appurata la presenza e la disponibilità di risorse su un determinato Host, il pacchetto dati composto dal dato vero e proprio e dall'header aggiunto dal livello Applicazione, è passato al sottostante livello Presentazione.

\section{Livelli Sessione e Presentazione}
\textbf{Il livello Presentazione} è il sesto livello del modello ISO/OSI ed è il primo livello ad occuparsi della semantica delle informazioni trasmesse. Ha la responsabilità di assicurare la compatibilità dei dati durante una comunicazione tra entità che utilizzano codifiche diverse. Questo avviene tramite una traduzione del dato in una forma universale e, quindi, comprensibile da altri Host. Nello specifico: una volta iniziata la comunicazione  in linea di principio, cambia il formato dei dati da quello del dispositivo mittente (\textit{sintassi locale}), a quello del dispositivo destinatario (\textit{sintassi di trasferimento})\\Questo strato offre, inoltre, importanti servizi quali la formattazione, la codifica, la criptatura e la compressione di dati. Se, ad esempio, si volesse convertire un file di testo scritto in EBCDIC (Extended Binary Coded Decimal Interchange Code) in un file scritto in  ASCII (American Standard Code for Information Interchange), tale conversione avverrebbe a questo livello. Un altro esempio si ha quando si invia un file di testo dal contenuto sensibile (come una password), ed è dunque necessario che il messaggio venga criptato. Tale operazione avviene proprio al livello Presentazione. \\Una volta finita l'elaborazione del pacchetto dati questo viene passato allo strato inferiore, il livello Sessione.\\\\
\textbf{Il livello Sessione} è il quinto livello del modello OSI e fornisce i meccanismi per stabilire, gestire ed, infine, concludere una comunicazione (\textit{o sessione}) tra una applicazione locale ed una remota, svolgendo inoltre un'operazione di verifica per assicurarsi della corretta ricezione del pacchetto dati. È solo a questo punto dello stack, infatti, dopo che il livello Applicativo e Presentazione hanno fornito i protocolli necessari ed adattato il pacchetto dati alla comunicazione che avviene la connessione, permettendo agli strati inferiori di attuare l'\textit{effettivo} invio del pacchetto dati. In base alla durata della sessione è possibile classificare le diverse tipologie di comunicazione. Una trasmissione si definisce \textbf{simplex}, quando la sessione dura al massimo il tempo necessario ad inviare un solo messaggio in una direzione. Un'altra modalità è la \textbf{half-duplex}, e si ha quando la trasmissione è sufficientemente lunga per una comunicazione bidirezionale ma capace di gestire un solo messaggio alla volta. L'ultima e più recente modalità è la \textbf{full-duplex}, la quale permette una comunicazione bidirezionale e simultanea. \\ Nel modello TCP/IP, tuttavia, questo livello non è presente e le modalità di instaurazione di una comunicazione tra due entità possono risultare più imprevedibili. Il livello Sessione è stato inglobato in parte nel livello Trasporto ed in parte nel livello Applicativo. Quando si va a richiedere una pagina Web tramite un Browser, nel TCP/IP i protocolli necessari vengono impilati direttamente sopra HTTP (\textbf{add-on}). Questa \textit{decomposizione funzionale} è stata applicata per far fronte alla necessità di integrare nuovi protocolli sugli stessi sistemi, senza che essi debbano essere stravolti, rendendo invece i nuovi protocolli compatibili con quelli antecedenti. Se, ad esempio, dovessimo caricare una pagina Web per guardare un programma in streaming, i protocolli necessari alla visualizzazione di essa verrebbero impilati sopra al livello Applicativo, partendo dal più semplice ed anziano HTTP, fino ad arrivare ai più recenti Javascript e PHP. (Figura 2.2).
\begin{figure}
\begin{center}
\begin{tikzpicture}[auto,
rect/.style={
  rectangle split, rectangle split parts=7,
  draw, thick,
  text width=4cm,
  text centered,
  rectangle split part fill={white}
}]

\node (stack) [rect] {
\nodepart {one} \Textbox{0.6cm}{...}
\nodepart {two} \Textbox{0.6cm}{PHP}
\nodepart{three} \Textbox{0.6cm}{JAVASCRIPT}
\nodepart{four}\Textbox{0.6cm}{CSS}
\nodepart{five} \Textbox{0.6cm}{HTML}
\nodepart{six} \Textbox{0.6cm}{HTTP}
\nodepart{seven} \Textbox{1.5cm}{TCP}

};
\end{tikzpicture} 
\end{center}
\caption {Stratificazione del livello Applicativo in caso di comunicazione Real-Time.}
\end {figure}
A livello Sessione dell'ISO/OSI vengono gestite anche le funzioni di autenticazione e autorizzazione e viene fornito il servizio di \textit{session restoration} (\textit{checkpointing and recovery}). Questo proverà, in caso di perdita di connessione, a ripristinarla riavviando se necessario la comunicazione.\\ Un esempio dei servizi offerti dal livello Sessione si ha durante una video chiamata, durante la quale è essenziale che il video e l'audio siano sincronizzati per evitare \textit{problemi di lip synch} (problemi di sincronizzazione del movimento delle labbra con l'audio). In caso di perdita di tale proprietà, essa verrà opportunamente gestita.\\Nel modello TCP/IP una sessione è gestita invece in tre fasi. La prima è quella di \textbf{Session Starting} (inizio sessione) nella quale il protocollo TCP adotta una una \textit{Three-Way-Handshake} (Figura 2.3) tra Client e Server per inizializzare la connessione. Più precisamente, come prima cosa il Client invia un messaggio \textit{SYN} (Synchronize) al Server per richiedere una sessione, il quale risponderà con un messaggio \textit{SYN ACK} (Synchronize Aknowledgment) per confermare la sincronizzazione e chiedere al Client se ha effettivamente richiesto una sessione. Infine il Client risponderà con un ultimo messaggio \textit{ACK} per confermare la richiesta di connessione ed avviare così la fase di trasmissione dei dati: \textbf{Data Trasmission}. L'ultima fase è quella di \textbf{Session Ending} (fine sessione), che avviene tramite una \textit{Four-Way-Handshake} (Figura 2.3) che inizia ad esempio con un messaggio \textbf{FIN ACK} (Finished) da Server a Client per avvisare quest'ultimo che i dati richiesti sono stati completamente trasmessi. A questo punto il Client risponderà un un messaggio \textbf{ACK} per confermare la ricezione del messaggio precedente. Una volta completato il download dei dati, il Client invierà un messaggio \textbf{FIN ACK} per avvisare il Server di aver terminato, il quale, provvederà a chiudere finalmente la connessione con un ultimo messaggio \textit{ACK} di conferma di ricezione.\\ UDP, l'alternativa a TCP/IP, è anch'esso caratterizzato da una sessione (se così si può chiamare) molto semplice. Quando, infatti, un'applicazione utilizza il protocollo UDP per inviare dei dati, i pacchetti sono semplicemente inviati senza che vi sia effettuato nessun tipo di controllo di corretta ricezione o di disponibilità del destinatario. Se quest'ultimo perdesse qualche pacchetto, questi sarebbero difatti semplicemente persi ed il mittente non provvederebbe ad inviarli nuovamente. Il lato positivo di questa tecnologia si ha dal punto di vista della velocità di comunicazione, incrementata dalla totale mancanza di controlli e garanzie. UDP è infatti utilizzato la dove la velocità di comunicazione è fondamentale, mentre la presenza e correzione degli errori non è rilevante.
Se ad esempio voi steste giocando ad un videogame online, è molto probabile che il protocollo a gestire il traffico dei pacchetti dati sia proprio UDP. Se quest'ultimo durante la trasmissione, per qualsivoglia motivo, non riuscisse a recapitare al vostro Client qualche pacchetto, comporterebbe un blocco momentaneo del gioco, al termine del quale il vostro personaggio potrebbe ritrovarsi teletrasportato all'improvviso in un diverso punto della mappa. Non essendoci, infatti, nessuna forma di \textit{session restoration}, il flusso di dati continuerà semplicemente a scorrere, ignorando l'errore.
\begin {figure}
\resizebox {\columnwidth}{!} {
\begin{tikzpicture}[font=\sffamily,>=stealth',thick,
commentl/.style={text width=3cm, align=right},
commentr/.style={commentl, align=left},]
\node[] (init) {\LARGE Server};
\node[right=1cm of init] (recv) {\LARGE Client};


\draw[->] ([yshift=-1.7cm]init.south) coordinate (fin1o) -- ([yshift=-.7cm]fin1o-|recv) coordinate (fin1e) node[pos=.3, above, sloped] {FIN ACK};

\draw[->] ([yshift=-.3cm]fin1e) coordinate (ack1o) -- ([yshift=-.7cm]ack1o-|init) coordinate (ack1e) node[pos=.3, above, sloped] {ACK};

\draw[->] (ack1e-|recv) coordinate (fin2o) -- ([yshift=-.7cm]fin2o-|init) coordinate (fin2e) node[pos=.3, above, sloped] {FIN ACK};

\draw[->] ([yshift=-.3cm]fin2e) coordinate (ack2o) -- ([yshift=-.7cm]ack2o-|recv) coordinate (ack2e) node[pos=.3, above, sloped] {ACK};

\draw[thick, shorten >=-1cm] (init) -- (init|-ack2e);
\draw[thick, shorten >=-1cm] (recv) -- (recv|-ack2e);

\draw[dotted] (recv.285)--([yshift=2mm]recv.285|-fin1e) coordinate[pos=.5] (aux1);

\draw[dotted] (init.255)--([yshift=2mm]init.255|-fin1o);

\draw[dotted] ([yshift=1mm]init.255|-fin2e) --([yshift=-5mm]init.255|-ack2e) coordinate (aux2);

\node[commentr, right =2mm of ack2e] {\textbf{CLOSED}};
\node[commentr, right =2mm of fin2o] {\textbf{LAST ACK}};
\node[below left = 0mm and 2mm of init.south, commentl]{\textbf{ESTABLISHED}\\[-1.5mm]{\itshape connection}};
\node[left = 2mm of fin1o.west, commentl]{{\itshape active close}\\[-1mm]\textbf{FIN\_WAIT\_1}};
\node[left = 2mm of ack1e.west, commentl]{\textbf{FIN\_WAIT\_2}};
\node[below left = -1mm and 2mm of fin2e.west, commentl]{\textbf{TIME\_WAIT}};
\node[below left = -1mm and 2mm of aux2-|init, commentl]{\textbf{CLOSED}};

\node[right = 2mm of recv|-aux1, commentr]{\textbf{ESTABLISHED}\\[-1.5mm]{\itshape connection}};
\node[right = 2mm of fin1e.west, commentr]{\textbf{CLOSE\_WAIT}\\[-1mm]{\itshape passive close}};
\end{tikzpicture}

\begin{tikzpicture}[font=\sffamily,>=stealth',thick,
commentl/.style={text width=3cm, align=right},
commentr/.style={commentl, align=left},]
\node[] (init) {\LARGE Server};
\node[right=1cm of init] (recv) {\LARGE Client};


\draw[->] ([yshift=1cm]fin1o-|recv) -- ([yshift=-2cm]init.south) coordinate (fin1o) coordinate (fin1e) node[pos=.3, above, sloped] {SYN};


\draw[->] ([yshift=1.5cm]fin2e) coordinate (ack2o) -- ([yshift=-.4cm]ack2o-|recv) coordinate (ack2e) node[pos=.3, above, sloped] {SYN ACK};

\draw[->] ([yshift=-1.5cm]fin1o-|recv) -- ([yshift=-4.5cm]init.south) coordinate (ack2e) coordinate (fin1e) node[pos=.3, above, sloped] {ACK};


\draw[thick, shorten >=-1cm] (init) -- (init|-ack2e);
\draw[thick, shorten >=-1cm] (recv) -- (recv|-ack2e);

\draw[dotted] (recv.285)--([yshift=2mm]recv.285|-fin1e) coordinate[pos=.5] (aux1);

\draw[dotted] (init.255)--([yshift=2mm]init.255|-fin1o);

\draw[dotted] ([yshift=1mm]init.255|-fin2e) --([yshift=-5mm]init.255|-ack2e) coordinate (aux2);


\node[right = 19mm of fin1o.west, commentl]{\textbf{SYN\_SENT}};

\node[below left = -10mm and 2mm of aux2-|init, commentl]{\textbf{ESTABLISHED}\\[-1.5mm]{\itshape connection}};


\node[below right = 0mm and 24mm of aux2-|init, commentl]{\textbf{ESTABLISHED}\\[-1.5mm]{\itshape connection}};
\node[left = -2mm of ack2o, commentr]{\textbf{SYN\_RECIVED}};
\node[below left = 0mm and 2mm of init.south, commentl]{\textbf{LISTEN}};
\end{tikzpicture}
}
\caption{Three Way Handshake (destra) e Four Way Handshake (sinistra)}
\end{figure}


\section{Evoluzione delle applicazioni Internet e Web}
Dalla nascita di \textit{\gls{ARPANET}} a cavallo tra gli anni '60 - '70 si sviluppò un'architettura per le reti di telecomunicazioni, che sarebbe poi stata indicata come Internet. Nel primo periodo della sua vita, la Rete, era in una \textit{fase di incubazione}, durante la quale veniva utilizzata solo dall'esercito con lo scopo di favorire l'efficienza nello sviluppo di nuove tecnologie di comunicazioni militari. A seguito di tale periodo e con il crescente interesse da parte della comunità scientifica, che si era occupata della sua progettazione e sviluppo, l'utilizzo della Rete venne esteso alle principali università americane, le quali, tramite ad esempio l'innovativo servizio di\textit{ posta elettronica}, avevano la possibilità di scambiare rapidamente documenti. La Rete si trovava allora nella \textit{fase accademica}. Negli stessi anni \textit{Tim Berners-Lee} creò un'architettura (e un servizio) che semplificò drasticamente l'utilizzo della Rete, ormai rinominata Internet, e ne rendeva possibile lo sfruttamento a fini commerciali, avviando difatti la sua \textit{fase commerciale}: il \textbf{\gls{WWW}}.Nel 1991 lo stesso Tim Berners-Lee, creò il primo sito Web, avviando implicitamente una rivoluzione che oggi chiamiamo \textbf{Web 1.0}.\\Il Web 1.0 si può classificare come l'Internet dei contenuti, caratterizzato da siti Web semplici e statici dai quali era possibile solo accedere a risorse senza poterle modificare o aggiungere. Le pagine Web erano scritte da una ristretta cerchia di persone e presentavano molti collegamenti ipertestuali statici (hyper link) ad altre pagine, in modo da dare all'utente una certa libertà di movimento all'interno della Rete (\textit{surfing)}. È col Web 1.0 che nacque il concetto di \textit{Web application}, cioè una variante del paradigma di tipo Client-Server che viene eseguita dal Client tramite un \textit{Web Browser}. Nel Web 1.0 il Client, rappresentato dal Browser, accedeva a pagine Web statiche rese accessibili da semplici Web Server. Infatti, come si nota dalla Figura 2.4, nella struttura della Rete non vi era nessun tipo di \textit{Web Database}, né tanto meno qualsivoglia tipo di servizio
\begin{figure}[h]
\begin{center}
\begin{tikzpicture}[auto,
  node distance = 0.5cm and 1cm, text centered,
 entity/.style = {rectangle, draw,
                   minimum width=3cm, minimum height=1cm, align=left},
net/.style = {cylinder, draw,
                   minimum width=1.5cm, minimum height=1cm, align=left, draw=black}, wapp/.style = {rectangle, draw,
                   minimum width=5cm, minimum height=4cm},
   arrow/.style = {thick,-stealth}
                    ]
\node (client)  [entity] {Web Client\\(Browser)};
\node (network)  [net,right=of client]   {Network};
\node (server) [wapp, right=of network]  (main) {Applicazione Web};
\node(webS) [entity] at ([yshift=2.3em]main.south){Web Server};
\node(webP) [entity] at ([yshift=3em]main.center){Pagine Web};
% connections

\draw [arrow] (client.north) --+ (0,0.5) -| (network) node[midway,sloped,right, rotate=90] {Richiesta};;
\draw [arrow] (network) -- (client);
\draw [arrow] (network) -- (main);
\draw [arrow] (webS.east) -- + (0.5,0) |- (webP);
\draw [arrow] (webP.west) --+  (-0.5,0) |- (webS);
\draw [arrow] (main.south) --+  (0,-0.5) -| (network) node[midway,sloped,left,rotate=270] {Risposta};
\end{tikzpicture}
\end{center}
\caption{Modello semplificato della struttura del Web 1.0}
\end{figure}
I Browser utilizzati per la navigazione erano molto semplici poiché l'unico linguaggio che dovevano \textit{interpretare} era l'HTML e non era volutamente richiesta nessun tipo di compilazione. Nel Web 1.0 non era inoltre prevista in alcun modo, la separazione tra i dati e la loro rappresentazione a livello di codice HTML, rendendo problematica la gestione, la manutenzione e l'aggiornamento. Se, ad esempio, doveva essere cambiata anche solo il font, si doveva andare a modificare l'intera pagina.  \\Le sessioni erano gestite soltanto dal protocollo HTTP, tutt'oggi ancora utilizzato. Questo ha la caratteristica di essere un protocollo\textit{ privo di stato} (\textit{state-less}) che, cioè, tratta ogni coppia richiesta-risposta tra Client e Server in modo indipendente dalle altre, causando di conseguenza la perdita di qualsiasi informazione scambiata all'interno di una ipotetica transazione. Ciò rendeva impossibile ad esempio, qualsiasi applicazione commerciale. Tale problema venne risolto inizialmente con l'introduzione dei \textbf{cookies}. Questi sono piccole stringhe di testo che vengono inviate da un Web Server ad un Web Client (solitamente un Browser) alla loro prima interazione, per poi essere rimandate indietro dal Client al Server ogni volta che il Client accederà alla stessa porzione dello stesso dominio Web. I cookies sono tutt'oggi molto utilizzati, essendo essi stati resi compatibili con le nuove strutture della Rete. Questo fenomeno di integrazione causò che le nuove architetture dovessero rispettare il principio di \textit{backward compatibility}. Tale principio prevede la possibilità di far cooperare tecnologie precedenti e successive, in modo che una eventuale innovazione non debba necessariamente portare ad una pesante manutenzione.\\\\
All'aumentare del numero dei servizi, degli utenti e dei loro requisiti, si rendeva sempre più necessaria la capacità di interagire con i contenuti stessi. Il mutamento fu veicolato da dei nuovi linguaggi di programmazione come \textit{PHP}, per mezzo dei quali iniziarono a crearsi i primi \textit{blog}, cioè siti Web sui quali era possibile inserire dei commenti. Questo significativo cambiamento comportò l'avvento delle prime \textit{community} e venne identificato come \textbf{Web 1.5}. \\Di lì a pochi anni la Rete si espanse in modo esponenziale con l'introduzione dei \textit{Wiki} e dei \textit{Social Network}, ponendo in primo piano l'interattività con l'utente ed aprendo la strada al cosiddetto \textbf{Web 2.0}.\\\\
Il livello applicativo, da un punto di vista funzionale, da statico divenne quindi dinamico, apportando modifiche architetturali principalmente lato Server, rendendolo cioè decisamente più complesso. Non si avevano più semplici pagine Web statiche, ma pagine Web più complesse e dinamiche, dotate di un elevato numero di servizi e script costantemente in comunicazione tra loro, per mezzo di specifici connettori, principalmente con \textit{database} (Figura 2.5). \\ Due dei servizi più innovativi furono gli \textit{RSS} ed i \textit{Podcast}. L'RSS (Really Simple Syndacation) è uno dei più popolari formati di distribuzione dei contenuti web basato su XML (eXtensible Markup Language) per mezzo del quale divenne possibile, tramite il meccanismo di feed-RSS, monitorare gli aggiornamenti di un sito senza visitarlo. Quest'ultima tecnologia rappresentò un vero punto di svolta nello sviluppo della Rete, in particolare per quanto riguarda la crescita dei \textit{social network}. Per mezzo di essa, i siti Web guadagnarono la capacità di ricevere e pubblicare continui aggiornamenti, come ad esempio la visualizzazione dei commenti associati ad un post di \textit{Facebook}. La funzionalità dei Podcast è molto simile ma, anziché monitorare ed aggiornare continuamente file di tipo testo o immagini, tramite tale meccanismo  fu possibile espandere il servizio ai file audio e video.\\\\
\begin{figure}[h]
\begin{center}
\resizebox{\columnwidth}{!}{
\begin{tikzpicture}[auto,
  node distance = 0.6cm and 1cm, text centered,
 entity/.style = {rectangle, draw,
                   minimum width=3cm, minimum height=1cm, align=center},
net/.style = {cylinder, draw,
                   minimum width=1.5cm, minimum height=1cm, align=center, draw=black},
conn/.style = {cylinder, draw,
                   minimum width=0.7cm, minimum height=1cm, align=center, draw=black},
data/.style = {cylinder, draw,
                   minimum width=3cm, minimum height=0.1cm, align=center, draw=black, shape border rotate=90,aspect=0.2}, wapp/.style = {rectangle, draw,
                   minimum width=5cm, minimum height=4cm},
   arrow/.style = {thick,-stealth}
                    ]
\node (client)  [entity] {Web Client\\(Browser)};
\node (network)  [net,right=of client]   {Network};
\node (server) [entity] [right=of network] {Web Server};

\node (script1) [entity] [right=of server] {Script/Servizi};
\node (script2) [entity] [below=of script1] {Script/Servizi};
\node (script3) [entity] [above=of script1] {Script/Servizi};

\node (connect1) [conn] at(14.5,0.7) {Connettore};
\node (connect2) [conn] at(14.5,-0.7) {Connettore};

\node (datab1) [data] at(18,0.6) {Web Database};
\node (datab2) [data] at(18,-0.8) {Web Database};

% connections

\draw [arrow] (client.north) --+ (0,0.5) -| (network) node[midway,sloped,right, rotate=90] {Richiesta};;
\draw [arrow] (network) -- (client);
\draw [arrow] (network) -- (main);
\draw [arrow] (network) -- (server);
\draw [arrow] (server.south) --+  (0,-0.5) -| (network) node[midway,sloped,left,rotate=270] {Risposta};

\draw [arrow] (server) -- (script1);
\draw [arrow] (server) -- (script2.west);
\draw [arrow] (server) -- (script3.west);
\draw [arrow] (script1) -- (server);
\draw [arrow] (script2.west) -- (server);
\draw [arrow] (script3.west) -- (server);


\draw [arrow] (script1.east) -- (connect1.west);
\draw [arrow] (script1.east) -- (connect2.west);
\draw [arrow] (script3.east) -- (connect1.west);
\draw [arrow] (script2.east) -- (connect2.west);
\draw [arrow] (connect1.west) -- (script1.east);
\draw [arrow] (connect2.west) -- (script1.east);
\draw [arrow] (connect1.west) -- (script3.east);
\draw [arrow] (connect2.west) -- (script2.east);

\draw[transform canvas] (connect1) to (datab1);
\draw[transform canvas] (connect2) to (datab2);

\end{tikzpicture}
}
\end{center}
\caption{Modello semplificato della struttura del Web 2.0 e 3.0.}
\end{figure}\\
Conseguentemente all'evoluzione del lato Server, i Browser divennero  più complessi eliminando le incompatibilità che vi erano in passato con le Web Application ed offrendo una vasta gamma di servizi adesso imprescindibili. Un esempio è rappresentato dall'introduzione di \textit{JavaScript}, per mezzo del quale si rese possibile eseguire codici direttamente sul Browser (\textit{scripting}). Un altro importante cambiamento fu quello portato da \textbf{HTTP/2}. Il protocollo HTTP non era infatti ancora mai stato cambiato dalla sua prima stesura (HTTP 1.1) del 1997, e col Web che si vedeva completamente rivoluzionato divenne una priorità avere un protocollo adatto alle nuove esigenze della Rete. HTTP/2 espanse il precedente protocollo senza cambiare le sue fondamenta, aggiungendo nuove funzioni e rendendo il processo di incapsulamento e trasferimento dei messaggi HTTP tra Client e Server, molto più veloce. In generale HTTP/2 non modificò la semantica di HTTP/1, ma modificò il modo in cui i dati venivano frammentati (\textit{framed}) in modo da diminuire la latenza. Questo avvenne con l'aggiunta del nuovo livello di \textit{binary framing}, posto tra l'interfaccia socket e l'API HTTP che, oltre a ridefinire il protocollo stesso da \textit{testuale} (textual) a \textit{binario} (binary), suddivise tutte le comunicazioni HTTP/2 in messaggi e frame più piccoli, ognuno dei quali codificato in formato binario.\\Con HTTP/1 se un Client voleva eseguire più richieste parallelamente per incrementare la velocità, era obbligato ad utilizzare più \textit{connessioni TCP} a causa della struttura stessa del modello di consegna di HTTP/1, il quale assicurava la consegna di una sola risposta alla volta per ogni connessione gestite tramite un'unica coda. Come conseguenza diretta si aveva un blocco della linea ed una inefficienza nell'uso della connessione TCP sottostante. Con l'arrivo di HTTP/2 ed il suo nuovo livello di framing queste limitazioni vennero superate e per mezzo della nuova tecnologia di \textit{multiplexing} divenne possibile per Client e Server, dividere un messaggio HTTP in frame indipendenti, di intervallarli e di ricomporli all'altro capo.\\\\ Col Web 2.0 si registrò un fortissimo aumento degli utenti e dei contenuti pubblicati. Basti infatti pensare al fatto che ogni post pubblicato da qualcuno su un qualsiasi social network rappresenta effettivamente un contenuto reperibile da chiunque su Internet.\\
Passando dal Web 1.0 al Web 2.0 ed in seguito ad una crescita esponenziale di utenti e di contenuti (Figura 2.7), si è venuto a creare un problema: se prima su Internet scarseggiavano i contenuti, questi divennero sovrabbondanti e si pose il problema della ricerca semantica dei contenuti stessi. Nella prima parte di vita del Web, i motori di ricerca erano molto semplici, poiché semplici erano le richieste che li potevano essere sottoposte. Con la crescita della Rete e l'ampliamento della tipologia e della mole dei contenuti reperibili su di essa, le esigenze degli utenti cambiarono, rendendo necessario un adeguamento dei motori di ricerca, mirato a restituire all'utente una corrispondenza sempre migliore. Fu così che gli algoritmi di ricerca sul Web fecero un primo passo verso l'\textit{intelligenza artificiale.} \\\\
Il \textbf{Web 3.0}, il \textit{\gls{WoT}}, è quello che utilizzeremo nel futuro immediato ed è basato sul paradigma dell'\textit{intelligenza semantica} ad oggi già in evoluzione. Se vi è mai capitato di utilizzare un assistente virtuale, o un qualsiasi oggetto di uso comune dotato di una connessione ad Internet, siete già entrati in contatto col WoT. Il concetto generale è infatti quello di interconnettere utenti umani ed oggetti (\textbf{things}), in tutto il mondo, attraverso la Rete, caratterizzando ogni soggetto con uno specifico URL (o indirizzo di Rete). In questa fase, il Web è rappresentato da un ambiente in cui ogni file pubblicato (pagine HTML, immagini, video, testi ecc...) entra \textit{concettualmente} a far parte di un enorme database, il\textit{ Web Database} nel quale ogni dato è interpretabile tramite \textit{metadati} associati ad esso che ne specificano il contesto semantico in un formato adatto all'interrogazione, all'interpretazione e, più in generale, all'elaborazione automatica intelligente. L'\textit{intelligenza} è infatti la caratteristica fondamentale di questa fase. Tramite algoritmi sempre più sofisticati che sfruttano l'intelligenza artificiale saranno sintetizzate a run time applicazioni capaci di interagire e collaborare tra loro e con gli utenti e di avere una vera e propria \textit{coscienza del contesto}, sfruttando la potenza della semantica. Si pensi, ad esempio, a cosa potrebbe accadere se un'applicazione calendario ed una di posta elettronica fossero in grado di comunicare tra loro in completa autonomia. Ogni volta che venisse fissato un appuntamento tramite e-mail, il calendario potrebbe aggiornarsi da solo, tramite le informazioni comunicategli dall'applicazione di posta elettronica.\\ Per far sì che ciò sia possibile, il Web 3.0 si basa sul concetto che tutte le fonti siano codificate secondo gli stessi criteri e che quindi tutti i documenti condividano la lingua con cui sono scritti. \\\\
\begin{figure}[h]
\begin{center}
\resizebox{5cm}{!}{
\begin{tikzpicture}[auto,
  node distance = 0.6cm and 1cm, text centered,
 entity/.style = {rectangle,
                   minimum width=0cm, minimum height=1cm, align=center},
   arrow/.style = {thick,-stealth}
                    ]
\node (ai)  [entity] at(2,2){AI};
\node (human)  [entity] at(0.5,0) {Human};
\node (things) [entity] at(3.5,0) {Things};


% connections

\draw [arrow] (ai.south) -- (human);
\draw [arrow] (ai.south) -- (things);
\draw [arrow] (things.west) -- (human.east);

\draw [arrow] (human) -- (ai.south);
\draw [arrow] (things) -- (ai.south);
\draw [arrow] (human.east) -- (things.west);

\end{tikzpicture}
}
\end{center}
\caption{Interfacce ed interazioni tra esse nel Web 3.0}
\end{figure}\\
Tuttavia, essendo la Rete è in continuo divenire, sullo sviluppo del Web 3.0 si possono fare solo congetture. Tim Berners-Lee vede il Web 3.0 come una rete raggiungibile da tutti, senza barriere, che tramite la semantica possa generare applicazioni Web nel complesso più efficaci di qualsiasi altra singola applicazione mai creata. Questa potenzialità, oltre che dal punto di vista della semantica è intesa anche dal punto di vista grafico, dove la \textit{grafica vettoriale scalabile} (SVG), secondo Tim Berners-Lee, prenderà il sopravvento. Per mezzo di essa è possibile esprimere figure interattive che possono essere ridefinite in qualsiasi momento ed in qualsiasi punto, senza perdere un grammo di qualità.\\Sicuramente col progredire del WoT, l'intera struttura del Web tenderà a mutare, portandoci in un futuro dove la Rete sarà costituita da utenti, \textit{things}, ed \textit{intelligenze artificiali} (IA) sempre più simili ad utenti reali (Figura 2.6). In una tale visione del futuro le interazioni tra questi tre soggetti saranno del tutto inedite. Si pensi ad esempio ad una IA che riceve feedback ed invia direttive ad un oggetto connesso alla rete in modo del tutto autonomo ed intelligente, o che crea contenuti su Internet, ad esempio su un social network, in modo indistinguibile da un essere umano. \\\\
È interessante pensare in questa prospettiva, a come si evolveranno i social network. Con l'avvento di ulteriori soggetti su Internet oltre alle persone fisiche, non sarebbe fuori luogo pensare a social network composti prevalentemente da IA e things.
Ci sono tuttavia persone che teorizzano si tenderà a conferire ai contenuti più gradi di libertà, non avendo più pagine ma \textbf{spazi} in cui poterci muovere tridimensionalmente per trovare ciò che cerchiamo. 
\begin{figure}[h]
\begin{center}
\includegraphics[width=14cm]{Immagini/webcontest.png}
\end{center}
\caption{Crescita della rete Internet}
\end{figure}



\section{Servizio DNS}

\section{Servizio Telnet}

\section{Servizio SMTP e POP/IMPAP}

\section{Servizio HTTP}

\subsection{Standard HTTP/1.0}

\subsection{Standard HTTP/1.1}

\subsection{Cache e Web Proxy}

\subsection{Standard HTTP/2.0}

\section{Paradigma Client-Server}

\subsection{Cloud, Fog e Edge Computing}

\subsection{Content Delivery Networks}

\section{Paradigma Peer-to-Peer}

\subsection{Protocollo BitTorrent}

\section{Social Networks}

\section{Blockchain}




\chapter{Tecnologie Web}\label{sec.TecnologieWeb}

\section{Linguaggio HTML}

\subsection{Evoluzione storica}

\subsection{Principali tag}

\subsection{CSS}

\subsection{Form}

\subsection{XHTML}

\subsection{HTML5}


\section{Linguaggio Javascript}

\section{Linguaggio PHP}

\section{Motori di ricerca Web}

\section{Web2.0}

\subsection{Paradigmi REST e SOAP}



\chapter{Livello Trasporto}\label{sec.Trasporto}

\section{Funzionalità}

\section{Socket API}

\section{Protocollo UDP}

\section{Protocollo TCP}

\subsection{Apertura di una sessione}

\subsection{Chiusura di una sessione}

\subsection{Protocollo Sliding Window}

\subsection{Protocolli di ritrasmissione}

\subsection{Formato del segmento}

\subsection{Adattamento del timeout}

\section{Controllo di congestione}

\subsection{Motivazione}

\subsection{Approccio AIMD}

\section{TCP Tahoe}


\subsection{ACK clocking}
\subsection{Slow-start}
\subsection{Congestion Control}

\section{TCP Reno}

\subsection{Fast Retransmission/Fast Recovery}

\section{TCPNewReno e SACK}

\section{TCP ECN}

\section{TCP Vegas}

\section{TCP Westwood}

\section{Protocollo RTP}
\section{Protocollo RTCP}
\section{Protocollo SIP}

\section{Mobile IP}

\end{document}
